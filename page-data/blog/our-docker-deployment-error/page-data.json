{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/our-docker-deployment-error/","webpackCompilationHash":"4d3c1df2c63372136643","result":{"data":{"site":{"siteMetadata":{"title":"My personal site"}},"markdownRemark":{"id":"e626c167-b493-508f-942f-4dcf6017dbb5","html":"<p>The frontend of the web application I am currently working on is built with React. It is entirely client-side rendered at the moment (we plan to add server-side rendering in the future), and is code-split into a number of chunks during production build. We also use a service worker to pre-cache the chunks. All pretty regular stuff.</p>\n<p>Since the project is still in its infancy, it is deployed to production by copying the built static assets to a Docker image with Nginx, and then spinning up a container from that image. This, I should say, is not how responsible grown-ups treat their static assets. Responsible grown-ups use CDNs.</p>\n<p>Our slightly infantile method of deployment means that every time we push an update to production, a new container with static files replaces the old container with static files — and then the old files are gone.</p>\n<p>Which was why, as we noticed, our application would break with every new deployment. The error message clearly said that the browser was trying to access javascript files which were no longer there. A page reload would restore the application to the working condition. My initial guess was that the problem happened when the user had their browser window open during the very moment when we pushed new code; and then when they navigated to a different page and requested the respective chunk of old javascript, it would no longer be available.</p>\n<p>But, an obvious question would immediately arise: why didn’t the service worker step in to supply the missing chunks? It was set up to pre-cache all the static files spewed out by Webpack; so why wasn’t it doing its job?</p>\n<p>The truth turned out to be more convoluted than what I initially suspected. Here is what was happening, step by step.</p>\n<p><strong>Pre-conditions.</strong> Webpack is configured to save static files with a content hash added to their names (to bust server-side caching or browser caching of static files), and also to use Workbox (a library for simple setting up of service worker, from Google):</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> WorkboxPlugin <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'workbox-webpack-plugin'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">WorkboxPlugin<span class=\"token punctuation\">.</span>GenerateSW</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  clientsClaim<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  skipWaiting<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Notice the <code class=\"language-text\">skipWaiting</code> option; it means that whenever the new version of service worker is downloaded, it will replace the currently active version of the service worker at the earliest possible moment (when the current worker finishes the work it is currently doing and yields to the newly arrived worker).</p>\n<p>Workbox webpack plugin by default pre-caches all assets generated by Webpack. These assets include the <code class=\"language-text\">index.html</code> file, which is sent to the client for client-side rendering.</p>\n<p><strong>Step 1.</strong> The user loads the home page for the first time. The html document is loaded from the server and cached by the service worker.</p>\n<p><strong>Step 2.</strong> The html document contains a link to the webpack runtime file (which has links to all javascript chunks generated by webpack during code splitting). This runtime file is downloaded from the server and cached by service worker.</p>\n<p><strong>Step 3.</strong> All javascript chunks listed in the runtime are, in turn, downloaded from the server and cached by the service worker. This is a good thing — it will speed up subsequent page loads, because there will be no need to download static files again.</p>\n<p><strong>Step 4.</strong> Developers make some updates to the code and push the updates to production. This triggers a job that will end up in generating a new docker container with new static files, which will replace the old one. At this point, all javascript files from the previous build, which were in the retired docker container, are gone.</p>\n<p><strong>Step 5.</strong> The user loads the home page of the site again.</p>\n<p><strong>Step 6.</strong> The service worker immediately supplies the old <code class=\"language-text\">index.html</code> (with the link to the old webpack runtime file) file to the browser.</p>\n<p><strong>Step 7.</strong> The service worker also immediately returns to the browser the old webpack runtime file (because it was cached), and the javascript chunks that are needed to display the page (they too are cached).</p>\n<p><strong>Step 8.</strong> One of the chunks contains the code for downloading an updated version of the service worker.</p>\n<p><strong>Step 9.</strong> New service worker arrives and replaces the service worker from the previous build. When it does so, it also clears the browser cache that the previous service worker created (this is all a part of how the Workbox library works). At this point, all the javascript files stored by the previous version of the service worker are removed from the browser.</p>\n<p><strong>Step 10.</strong> User navigates to a different screen. Due to code splitting, the webpack runtime requests the javascript chunk that is responsible for rendering of this screen.</p>\n<p><strong>Step 11.</strong> But the webpack runtime is old (see Step 7); and so it requests the file with an old name. That file no longer exists anywhere. It was removed from the server when the new container replaced the old one (Step 4), and it was removed from the browser cache when the new service worker replaced the old one (Step 9).</p>\n<p><strong>Step 12.</strong> The request for the non-existing file returns a 404 error response. This breaks the site.</p>\n<p>So how can this problem be solved?</p>\n<ol>\n<li>Do not pre-cache index.html in the service worker:</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">new</span> <span class=\"token class-name\">WorkboxPlugin<span class=\"token punctuation\">.</span>GenerateSW</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  clientsClaim<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  skipWaiting<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  exclude<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token regex\">/index.html$/</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>This should prevent the situation when the user receives obsolete index.html from cache with a link to the outdated webpack runtime file from the previous build.</p>\n<ol start=\"2\">\n<li>Perhaps do not use the <code class=\"language-text\">skipWaiting</code> option? This should keep the newly arrived service worker waiting until the user refreshes the page again; so there won’t be a situation when part of the static files came from the cache, and then the cache, with the rest of the files, got busted.  </li>\n<li>Do not store static files in docker image. Develop a scalable strategy for storing static files from multiple previous builds (by either copying them in a volume that is mounted by containers, or uploading them to a CDN).</li>\n</ol>\n<p><strong>P.S.:</strong> A related problem is <a href=\"https://spectrum.chat/react/general/how-to-handle-deployments-with-webpack-code-splitting~16dc5f85-0b4b-4eee-8693-066d82dcdc7f\">discussed</a> on Spectrum.</p>","frontmatter":{"title":"How our use of service workers and Docker containers caused an error","date":"03 August, 2019"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/our-docker-deployment-error/"}}}